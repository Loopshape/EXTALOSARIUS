<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AEGIS — Navigation & Flight Systems</title>
<!-- Load Three.js and GSAP -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<style>
:root{--bg:#020406;--fg:#a0c0ff;--accent:#00ff88;--warn:#ff4400;--panel:#0b1620dd}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:'Segoe UI', Inter, Arial, sans-serif; overflow: hidden;}
.app{display:flex;height:100vh;gap:12px;padding:12px;box-sizing:border-box}

/* HUD Styling */
aside{width:380px;background:var(--panel);border: 1px solid #1a4a3a; border-radius:4px;padding:16px;display:flex;flex-direction:column; backdrop-filter: blur(10px); z-index: 10;}
main{flex:1;display:flex;flex-direction:column; position: relative;}
canvas{width:100%;height:100%;background:#000;border-radius:4px;display:block; border: 1px solid #1a4a3a;}

h1{margin:0 0 4px 0;font-size:20px; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--accent);}
h2{margin:0 0 12px 0;font-size:10px; color: #597; text-transform: uppercase; letter-spacing: 1px;}

.controls{display:flex;gap:8px;flex-wrap:wrap}
.card{background:#0f2a2088;padding:10px;border-radius:4px;margin-bottom:12px; border-left: 2px solid var(--accent); position:relative;}
.card::after{content:''; position:absolute; top:0; right:0; width:10px; height:10px; border-top:1px solid var(--accent); border-right:1px solid var(--accent);}

label{display:block;font-size:10px;color:#6a8; text-transform: uppercase; margin-bottom: 4px; font-weight: bold;}
select,input,button,textarea{width:100%;padding:8px;border-radius:2px;border:1px solid #243;color:#dff;background:#0008; font-family: monospace; box-sizing: border-box; outline: none;}
input:focus, textarea:focus {border-color: var(--accent);}

button{cursor: pointer; background: linear-gradient(90deg, #00ff8811, transparent); transition: 0.2s; border: 1px solid #00ff8844;}
button:hover{background: #00ff8833; color: #fff; border-color: var(--accent);}

.agent-list{display:grid;grid-template-columns:1fr 1fr;gap:6px}
.agent{padding:6px;border-radius:2px;background:#0005;display:flex;flex-direction:column; border: 1px solid #1a4a3a;}
.log{height:140px;overflow:auto;background:#0005;padding:8px;border-radius:2px;font-family:'Courier New', monospace;font-size:11px; color: #8ba; border: 1px solid #ffffff11;}
.log::-webkit-scrollbar {width: 4px;}
.log::-webkit-scrollbar-thumb {background: var(--accent);}

/* Overlay UI */
/* IMPORTANT: The ufo-label position must be absolute relative to the body for correct 2D overlay */
.ufo-label{position:absolute;padding:2px 6px;border-radius:2px;background:rgba(5,20,10,0.8);border: 1px solid var(--accent); color:var(--accent);font-family:monospace;font-size:9px;pointer-events:none;transform:translate(-50%,-50%); transition: opacity 0.3s; white-space: nowrap; z-index: 100;}
.ufo-line{position:absolute; height:1px; background:var(--accent); transform-origin: 0 50%; opacity:0.5; pointer-events:none;}

#stats{white-space: pre-wrap; line-height: 1.4; color: #00ff88;}
.blink{animation: blink 2s infinite;}
@keyframes blink {0%{opacity:1} 50%{opacity:0.5} 100%{opacity:1}}
</style>
</head>
<body>
<div class="app">
  <aside>
    <h1>AEGIS Navigation</h1>
    <h2>System: Vector Flight Path</h2>
    
    <div class="card">
      <label>Navigation Control</label>
      <div style="font-family:monospace; font-size:11px; margin-bottom:8px; color:#00ff88;" class="blink">
        >> NAVIGATION MODE: ACTIVE<br>
        >> CHRONOLOGIC LOCK: STABLE
      </div>
      <textarea id="genesisPrompt" rows="2">Calculate sector hash for warp insertion. Align vector pointer.</textarea>
      <button id="genesisBtn">PLOT TRAJECTORY</button>
      <div style="margin-top:8px;"><label>Sector Hash</label><input id="genesisHash" readonly value="CALCULATING..." style="color:#597"/></div>
    </div>

    <div class="card">
      <label>AI Core Link (Ollama)</label>
      <div class="controls">
        <select id="modelSelect">
          <option value="llama3">llama3</option>
          <option value="mistral">mistral</option>
          <option value="gemma">gemma</option>
          <option value="phi3">phi3</option>
        </select>
        <button id="probeModels">PING CORE</button>
      </div>
      <div style="margin-top:8px"><label>Network Node</label><input id="ollamaUrl" value="http://localhost:11434" /></div>
    </div>

    <div class="card">
      <label>Crew Status (2π/8)</label>
      <div class="agent-list" id="agents"></div>
      <div style="margin-top:8px"><button id="runCycle">POLL NAVIGATORS</button></div>
    </div>

    <div class="card">
      <label>Flight Log</label>
      <div class="log" id="log"></div>
    </div>
  </aside>

  <main>
    <!-- 3D Viewport -->
    <div id="scene-container" style="flex:1; position:relative; overflow:hidden;"></div>
    
    <!-- Bottom Panel -->
    <div style="display:flex;gap:8px;margin-top:8px; height: 160px; z-index:10;">
      <div class="card" style="flex:1; overflow: hidden; display:flex; flex-direction:column;">
        <label>Comms Array</label>
        <div id="agentOutput" class="log" style="flex:1; height:auto; color:#ccc;">Listening on nav-comms...</div>
      </div>
      <div class="card" style="width:300px; overflow: hidden; display:flex; flex-direction:column; background: #001a11ee;">
        <label>Navigational Telemetry</label>
        <div id="stats" class="log" style="flex:1; height:auto;">Acquiring signal...</div>
      </div>
    </div>
  </main>
</div>

<script type="module">
// ======================= THREE.JS AEGIS SETUP =======================

const container = document.getElementById('scene-container');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020406, 0.005); 

// Camera Setup
const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 3000);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
container.appendChild(renderer.domElement);

// --- Lighting (Increased brightness from previous step) ---
const ambientLight = new THREE.AmbientLight(0x404040, 1.0); 
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
sunLight.position.set(100, 50, 80);
scene.add(sunLight);

const navLight = new THREE.PointLight(0x00ff88, 3, 100);
navLight.position.set(20, 0, 0);
scene.add(navLight);

// --- 1. The Earth (Distant) ---
const earthGeo = new THREE.SphereGeometry(80, 64, 64);
const earthMat = new THREE.MeshStandardMaterial({ 
    color: 0x051020, 
    roughness: 0.6, 
    emissive: 0x000510,
    emissiveIntensity: 0.3
});
const earth = new THREE.Mesh(earthGeo, earthMat);
earth.position.set(0, -150, 0); 
scene.add(earth);

const atmoGeo = new THREE.SphereGeometry(82, 32, 32);
const atmoMat = new THREE.MeshBasicMaterial({ color: 0x0044ff, transparent: true, opacity: 0.05, side: THREE.BackSide });
const atmo = new THREE.Mesh(atmoGeo, atmoMat);
earth.add(atmo);


// --- 2. The AEGIS Carrier (Procedural) ---
const aegisGroup = new THREE.Group();
aegisGroup.name = "AEGIS_SHIP";
scene.add(aegisGroup);

// Materials
const hullMat = new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.4, metalness: 0.8 });
const darkMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 });
const windowMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.0, metalness: 1.0, emissive: 0x003322 });
const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa });

// --- Structure: Main Hull (Sleek Wedge) ---
const mainHullGeo = new THREE.BufferGeometry();
const vertices = new Float32Array([
    // Front Nose (Pointed)
    10.0, 0.0, 0.0, 
    // Mid-Front (Wider)
    4.0, 2.0, 4.0,
    4.0, 2.0, -4.0,
    4.0, -2.0, -4.0,
    4.0, -2.0, 4.0,
    // Rear (Boxy)
    -8.0, 2.0, 4.0,
    -8.0, 2.0, -4.0,
    -8.0, -2.0, -4.0,
    -8.0, -2.0, 4.0,
]);
const indices = new Uint16Array([
    // Front Faces (Nose)
    0, 2, 1, 0, 3, 2, 0, 4, 3, 0, 1, 4,
    // Top, Bottom, Sides (Mid to Rear)
    1, 2, 6, 1, 6, 5, // Top
    3, 4, 8, 3, 8, 7, // Bottom
    4, 1, 5, 4, 5, 8, // Right Side
    2, 3, 7, 2, 7, 6, // Left Side
    // Rear End
    5, 6, 7, 5, 7, 8
]);

mainHullGeo.setIndex(new THREE.BufferAttribute(indices, 1));
mainHullGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
mainHullGeo.computeVertexNormals();
const mainHull = new THREE.Mesh(mainHullGeo, hullMat);
aegisGroup.add(mainHull);

// --- 3. Red Geometric Scheme Layer (Structural Integrity) ---
const redMeshMat = new THREE.MeshBasicMaterial({ 
    color: 0xff0000, 
    wireframe: true, 
    transparent: true, 
    opacity: 0.6,
    depthTest: false 
});

const redMeshLayer = new THREE.Mesh(mainHullGeo, redMeshMat);
redMeshLayer.scale.set(1.02, 1.02, 1.02); 
aegisGroup.add(redMeshLayer);

// --- 4. Blue Ablative Layer (Gravitic Field / Shield) ---
const blueSphereGeo = new THREE.SphereGeometry(14, 16, 16); // Radius 14, encompassing the hull
const blueMeshMat = new THREE.MeshBasicMaterial({ 
    color: 0x00aaff, // Blue color
    wireframe: true, 
    transparent: true, 
    opacity: 0.3, // Subtle effect
    depthTest: false 
});

const blueMeshLayer = new THREE.Mesh(blueSphereGeo, blueMeshMat);
aegisGroup.add(blueMeshLayer);

// --- Cockpit ---
const cockpitGeo = new THREE.ConeGeometry(0.8, 4, 8);
cockpitGeo.rotateX(Math.PI / 2);
cockpitGeo.translate(6, 0.2, 0);
const cockpit = new THREE.Mesh(cockpitGeo, windowMat);
aegisGroup.add(cockpit);

// --- Swept-Back Pylons/Wings (Existing code for context) ---
const pylonGeo = new THREE.BoxGeometry(10, 0.5, 2);
const lPylon = new THREE.Mesh(pylonGeo, darkMat);
lPylon.position.set(-2, 1, 6);
lPylon.rotation.y = -0.3;
lPylon.rotation.z = -0.1;
aegisGroup.add(lPylon);

const rPylon = new THREE.Mesh(pylonGeo, darkMat);
rPylon.position.set(-2, 1, -6);
rPylon.rotation.y = -0.3;
rPylon.rotation.z = 0.1;
aegisGroup.add(rPylon);

// --- Engines (Integrated) (Existing code for context) ---
const engineGeo = new THREE.CylinderGeometry(1.2, 1.2, 4, 16);
engineGeo.rotateZ(Math.PI / 2);

const lEngineHousing = new THREE.Mesh(engineGeo, hullMat);
lEngineHousing.position.set(-6, 0.7, 10.5);
lEngineHousing.rotation.y = -0.3;
const lCoreGeo = new THREE.ConeGeometry(0.8, 5, 16, 1, true);
lCoreGeo.rotateZ(-Math.PI / 2);
lCoreGeo.translate(-2, 0, 0);
const lCore = new THREE.Mesh(lCoreGeo, engineMat);
lEngineHousing.add(lCore);
aegisGroup.add(lEngineHousing);

const rEngineHousing = new THREE.Mesh(engineGeo, hullMat);
rEngineHousing.position.set(-6, 0.7, -10.5);
rEngineHousing.rotation.y = 0.3;
const rCoreGeo = new THREE.ConeGeometry(0.8, 5, 16, 1, true);
rCoreGeo.rotateZ(-Math.PI / 2);
rCoreGeo.translate(-2, 0, 0);
const rCore = new THREE.Mesh(rCoreGeo, engineMat);
rEngineHousing.add(rCore);
aegisGroup.add(rEngineHousing);


// --- NAVIGATION VISUALS ---

// 1. Trajectory Line
const trajPts = [];
for(let i=0; i<100; i++) {
    trajPts.push(new THREE.Vector3(10 + i * 2, 0, 0)); // Points forward from nose
}
const trajGeo = new THREE.BufferGeometry().setFromPoints(trajPts);
const trajMat = new THREE.LineDashedMaterial({
    color: 0x00ff88,
    linewidth: 1,
    scale: 1,
    dashSize: 3,
    gapSize: 2,
    transparent: true,
    opacity: 0.5
});
const trajectoryLine = new THREE.Line(trajGeo, trajMat);
trajectoryLine.computeLineDistances();
aegisGroup.add(trajectoryLine); // Attach to ship

// 2. Waypoint Marker (Distant Target)
const waypointGroup = new THREE.Group();
waypointGroup.position.set(200, 20, 0); // Ahead of ship in global coordinates
scene.add(waypointGroup);

const wpGeo = new THREE.BoxGeometry(4, 4, 4);
const wpMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, wireframe: true });
const waypoint = new THREE.Mesh(wpGeo, wpMat);
waypointGroup.add(waypoint);

// Waypoint Inner
const wpInnerGeo = new THREE.OctahedronGeometry(1.5);
const wpInnerMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
const wpInner = new THREE.Mesh(wpInnerGeo, wpInnerMat);
waypointGroup.add(wpInner);

// Connector Line to Waypoint
const connectorMat = new THREE.LineBasicMaterial({ color: 0x004433, transparent: true, opacity: 0.3 });
// Adjust connector to account for rebuilt ship's scale
const connectorGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(-200, -20, 0)]);
const connector = new THREE.Line(connectorGeo, connectorMat);
waypointGroup.add(connector);


// --- 3. Starfield (Streaking effect for movement) ---
const starGeo = new THREE.BufferGeometry();
const starCount = 3000;
const starPos = new Float32Array(starCount * 3);
for(let i=0; i<starCount*3; i++) {
    starPos[i] = (Math.random() - 0.5) * 1000;
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({color: 0xaaccff, size: 0.5, transparent: true, opacity: 0.8});
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);


// ======================= LOGIC BRIDGE =======================

const agentNames = ['COORDINATOR','NAVIGATOR','DOCTOR','PREDICTOR','ADVISER','CONSTELLATOR','MARKETER','COMMUNICATOR'];
let agentsData = [];
let agentMeshes = [];

// Helper: Text Label Overlay
function createLabel(text) {
    const div = document.createElement('div');
    div.className = 'ufo-label';
    div.textContent = text;
    document.body.appendChild(div);
    return div;
}

function spawnAgents3D(hash) {
    // Clear existing agents from the scene graph
    agentMeshes.forEach(a => { 
        // Agents are children of aegisGroup
        aegisGroup.remove(a.mesh); 
        if(a.label) a.label.remove(); 
    });
    agentMeshes = [];
    agentsData = [];
    const count = 8;
    const radius = 18;

    for(let i=0; i<count; i++) {
        const name = agentNames[i];
        const angle = (i / count) * Math.PI * 2;
        const geo = new THREE.OctahedronGeometry(0.4);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ff88, wireframe: true });
        const mesh = new THREE.Mesh(geo, mat);
        
        // Add mesh to aegisGroup so it moves with the ship
        mesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
        aegisGroup.add(mesh); 
        
        const label = createLabel(name);
        const agentObj = { id: i, name: name, mesh: mesh, label: label, angle: angle, radius: radius, speed: 0.003 + (Math.random() * 0.002) };
        agentMeshes.push(agentObj);
        agentsData.push(agentObj);
    }
    renderAgentsList();
}

function renderAgentsList(){ 
  const wrap = document.getElementById('agents'); wrap.innerHTML='';
  agentsData.forEach(a=>{
    const el = document.createElement('div'); el.className='agent';
    el.innerHTML = `<strong>${a.name}</strong><small style="color:#00ff88">ON STATION</small>`;
    wrap.appendChild(el);
  }); 
}

// --- Animation Loop ---
let time = 0;

function animate() {
    requestAnimationFrame(animate);
    time += 0.01;

    // 1. Ship Motion (Floating and slow yaw for visibility)
    aegisGroup.position.y = Math.sin(time * 0.5) * 1;
    aegisGroup.rotation.z = Math.sin(time * 0.2) * 0.05;
    aegisGroup.rotation.y = Math.sin(time * 0.1) * 0.1; // Gentle yaw
    
    // Animate the red mesh layer: Pulsation kept, locked to ship direction.
    redMeshLayer.scale.setScalar(1.02 + Math.sin(time * 2) * 0.01);

    // Animate the blue sphere layer (Shield): Independent rotation around ship is intentional.
    blueMeshLayer.rotation.y += 0.005;
    blueMeshLayer.scale.setScalar(1 + Math.sin(time * 1.5) * 0.015);

    // 2. Trajectory Animation (Marching ants effect)
    trajMat.dashSize = 3; 
    trajMat.gapSize = 2;
    trajMat.opacity = 0.5 + Math.sin(time * 10) * 0.3;

    // 3. Waypoint Animation
    waypoint.rotation.x += 0.01;
    waypoint.rotation.y -= 0.01;
    wpInner.rotation.x -= 0.02;
    wpInner.scale.setScalar(1 + Math.sin(time * 4) * 0.2);
    
    // 4. Starfield Parallax (Simulate forward velocity)
    const positions = stars.geometry.attributes.position.array;
    for(let i = 0; i < starCount; i++) {
        // Move stars backward along X axis (Ship faces +X)
        positions[i * 3] -= 0.5; 
        if(positions[i * 3] < -500) positions[i * 3] = 500; // Loop
    }
    stars.geometry.attributes.position.needsUpdate = true;

    // 5. Update Agents
    agentMeshes.forEach(a => {
        a.angle += a.speed;
        // Position is relative to aegisGroup
        a.mesh.position.x = Math.cos(a.angle) * a.radius;
        a.mesh.position.z = Math.sin(a.angle) * a.radius;
        // Navigation bob
        a.mesh.position.y = Math.sin(time + a.angle * 4) * 0.5; // Bob relative to ship's center
        a.mesh.rotation.y += 0.02;
        updateLabelPosition(a.mesh, a.label);
    });

    // 6. Camera (Adjusted for better view of rebuilt ship)
    const targetPos = aegisGroup.position.clone();
    camera.position.set(35, 20, 45); // Slightly wider and higher angle
    camera.lookAt(targetPos);

    renderer.render(scene, camera);
    updateStats();
}

function updateLabelPosition(mesh, label) {
    if(!label) return;
    const tempV = new THREE.Vector3();
    
    // 1. Get Global Position
    mesh.updateWorldMatrix(true, false);
    mesh.getWorldPosition(tempV);
    
    // 2. Project to Clip Space
    tempV.project(camera);
    
    // Check Z-depth (behind camera)
    if(Math.abs(tempV.z) > 1) { 
        label.style.opacity = 0; 
        return;
    }
    
    // Get the bounding box of the container to calculate offset
    const rect = container.getBoundingClientRect();

    // 3. Map Clip Space (-1 to 1) to Screen Space (0 to width/height of container)
    const x = (tempV.x * .5 + .5) * rect.width;
    const y = (tempV.y * -.5 + .5) * rect.height; // Note: Y is inverted in screen space
    
    // 4. Add container's global offset (rect.left/top) for absolute positioning on document.body
    const finalX = x + rect.left;
    const finalY = y + rect.top;
    
    label.style.opacity = 1; 
    label.style.left = `${finalX}px`; 
    label.style.top = `${finalY}px`; 
}

function updateStats() {
    const statBox = document.getElementById('stats');
    const velocity = (299792 + Math.random()*100).toFixed(0);
    const dist = (149.6 - (time * 0.01)).toFixed(6);
    
    statBox.innerHTML = `
    <strong>FLIGHT VECTOR [ACTIVE]</strong>
    -------------------
    HEADING:   274.5° MARK 6
    VELOCITY:  ${velocity} KM/S
    SECTOR:    ORION-CYGNUS
    -------------------
    WAYPOINT LOCK:
    > DIST: ${dist} AU
    > HASH: 0x${Math.floor(time*1000).toString(16).toUpperCase()}
    -------------------
    GEOMETRIC FIELD: ONLINE
    ABLATIVE SHIELD: ACTIVE
    `;
}

// ======================= UI & INTERACTION =======================

function log(s){ const l = document.getElementById('log'); l.innerText = `[${new Date().toLocaleTimeString()}] ${s}\n`+l.innerText; }
async function sha256hex(str){ const enc = new TextEncoder().encode(str); const hash = await crypto.subtle.digest('SHA-256', enc); return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join(''); }

window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
});

document.getElementById('genesisBtn').addEventListener('click', async ()=>{
  const prompt = document.getElementById('genesisPrompt').value; 
  const hash = await sha256hex(prompt);
  document.getElementById('genesisHash').value = hash.substring(0,16);
  log(`COURSE PLOTTED: ${hash.substring(0,8)}...`);
  spawnAgents3D(hash);
  gsap.fromTo(trajectoryLine.scale, {x:0}, {x:1, duration:1, ease:"power2.out"});
});

document.getElementById('runCycle').addEventListener('click', async ()=>{
  const ollamaUrl = document.getElementById('ollamaUrl').value;
  const selectedModel = document.getElementById('modelSelect').value;
  const genesisPrompt = document.getElementById('genesisPrompt').value;
  const runCycleButton = document.getElementById('runCycle');

  log(`Querying Navigation Stations...`);
  runCycleButton.disabled = true; // Disable button during polling
  document.getElementById('agentOutput').innerText = 'Polling agents... Stand by.';

  const tasks = agentsData.map(async (a) => {
    gsap.to(a.mesh.scale, {x:1.5, y:1.5, z:1.5, duration:0.2, yoyo:true, repeat:1});
    try {
        const agentPrompt = `You are ${a.name} (Navigation Officer) on AEGIS. The current mission objective is: "${genesisPrompt}". Report current vector status, making sure to relate it to the mission objective.`;
        const res = await fetch(`${ollamaUrl}/api/generate`, {
            method:'POST',
            body: JSON.stringify({model: selectedModel, prompt: agentPrompt, stream: false})
        });
        if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`API error for ${a.name}: ${res.status} - ${errorText}`);
        }
        const data = await res.json();
        return `[${a.name}]: ${data.response}`;
    } catch(e) {
        log(`ERROR polling ${a.name}: ${e.message}`); // Log the actual error
        await new Promise(r => setTimeout(r, 200 + Math.random()*800)); // Simulate delay for fallback
        const responses = [
            "Vector alignment at 99.9%.",
            "Geometric field holding steady.",
            "Ablative shield nominal, 100% integrity.",
            "Chronologic drift minimal.",
            "Holding course. Engines optimal.",
            "Waypoint Delta in visual range."
        ];
        return `[${a.name}]: ${responses[Math.floor(Math.random()*responses.length)]} (Fallback)`;
    }
  });

  const results = await Promise.all(tasks);
  document.getElementById('agentOutput').innerText = results.join('\n\n');
  log("Navigation poll complete.");
  runCycleButton.disabled = false; // Re-enable button
});

document.getElementById('probeModels').addEventListener('click', async ()=>{
  log('Pinging Nav Computer...');
  const ollamaUrl = document.getElementById('ollamaUrl').value;
  try {
    const response = await fetch(`${ollamaUrl}/api/tags`);
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    const modelSelect = document.getElementById('modelSelect');
    modelSelect.innerHTML = ''; // Clear existing options
    data.models.forEach(model => {
        const option = document.createElement('option');
        option.value = model.name;
        option.textContent = model.name;
        modelSelect.appendChild(option);
    });
    log(`Nav Computer responded. Found ${data.models.length} models.`);
  } catch (e) {
    log(`ERROR: Nav Computer offline or unresponsive: ${e.message}`);
  }
});

// Start
log("SYSTEM STARTUP: NAVIGATION ONLINE.");
spawnAgents3D('init');
animate();

</script>
</body>
</html>
